<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Breakout</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        #canvas { display: block; }
        
        .hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 50px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 15px;
            border: 3px solid #00ff88;
            font-size: 28px;
            color: #00ff88;
            z-index: 100;
        }
        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .hud-label {
            font-size: 18px;
            color: #00ffff;
            margin-bottom: 5px;
        }
        .hud-value {
            font-size: 36px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px 80px;
            border-radius: 20px;
            border: 4px solid #ff3366;
            text-align: center;
            display: none;
            z-index: 200;
        }
        .game-over h1 {
            font-size: 64px;
            color: #ff3366;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #ff3366;
        }
        .game-over .final-score {
            font-size: 32px;
            color: #00ff88;
            margin-bottom: 40px;
        }
        .game-over button {
            font-size: 28px;
            padding: 20px 60px;
            background: #00ff88;
            border: none;
            border-radius: 10px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        .game-over button:hover {
            background: #00ffaa;
            transform: scale(1.05);
        }
        
        .win {
            border-color: #00ff88 !important;
        }
        .win h1 {
            color: #00ff88 !important;
            text-shadow: 0 0 20px #00ff88 !important;
        }
        
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            font-size: 20px;
            color: #00ffff;
        }
        
        #canvas {
            cursor: none;
        }
        
        .crosshair {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #00ff88;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #00ff88;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="hud">
        <div class="hud-item">
            <div class="hud-label">SCORE</div>
            <div class="hud-value" id="score">0</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">LIVES</div>
            <div class="hud-value" id="lives">3</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">LEVEL</div>
            <div class="hud-value" id="level">1</div>
        </div>
    </div>
    
    <div class="game-over" id="game-over">
        <h1 id="game-over-title">GAME OVER</h1>
        <div class="final-score">SCORE: <span id="final-score">0</span></div>
        <button onclick="restartGame()">PLAY AGAIN</button>
    </div>
    
    <div class="instructions">
        Move: MOUSE â€¢ Launch: CLICK
    </div>
    
    <div class="crosshair" id="crosshair"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 20, 50);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        
        camera.position.set(0, 12, 8);
        camera.lookAt(0, 0, 0);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(5, 10, 5);
        mainLight.castShadow = true;
        scene.add(mainLight);
        
        const glowLight = new THREE.PointLight(0x00ff88, 1, 20);
        scene.add(glowLight);
        
        // Game area bounds
        const areaWidth = 10;
        const areaDepth = 15;
        
        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x003333,
            emissive: 0x002222,
            roughness: 0.7
        });
        
        const leftWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 2, areaDepth),
            wallMaterial
        );
        leftWall.position.set(-areaWidth/2, 1, 0);
        scene.add(leftWall);
        
        const rightWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 2, areaDepth),
            wallMaterial
        );
        rightWall.position.set(areaWidth/2, 1, 0);
        scene.add(rightWall);
        
        const backWall = new THREE.Mesh(
            new THREE.BoxGeometry(areaWidth, 2, 0.2),
            wallMaterial
        );
        backWall.position.set(0, 1, -areaDepth/2);
        scene.add(backWall);
        
        // Floor
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(areaWidth, areaDepth),
            new THREE.MeshStandardMaterial({ 
                color: 0x001111,
                roughness: 0.9
            })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Grid
        const gridHelper = new THREE.GridHelper(areaDepth, 15, 0x00ff88, 0x003322);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);
        
        // Paddle
        let paddle = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.3, 0.8),
            new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 0.5,
                metalness: 0.7,
                roughness: 0.3
            })
        );
        paddle.position.set(0, 0.15, 5);
        paddle.castShadow = true;
        scene.add(paddle);
        
        // Ball
        let ball = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 16, 16),
            new THREE.MeshStandardMaterial({
                color: 0xff3366,
                emissive: 0xff3366,
                emissiveIntensity: 0.8,
                metalness: 0.9,
                roughness: 0.1
            })
        );
        ball.position.set(0, 0.5, 4);
        ball.castShadow = true;
        scene.add(ball);
        
        // Ball trail
        const trailGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const trailMaterial = new THREE.MeshBasicMaterial({
            color: 0xff3366,
            transparent: true,
            opacity: 0.3
        });
        const trails = [];
        
        // Blocks
        const blocks = [];
        const blockColors = [0xff0000, 0xff6600, 0xffcc00, 0x00ff00, 0x0099ff];
        
        function createBlock(x, z, colorIndex, points) {
            const blockWidth = 1;
            const blockDepth = 0.4;
            const color = blockColors[colorIndex % blockColors.length];
            
            const blockMesh = new THREE.Mesh(
                new THREE.BoxGeometry(blockWidth, 0.5, blockDepth),
                new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    metalness: 0.6,
                    roughness: 0.4
                })
            );
            blockMesh.position.set(x, 0.25, z);
            blockMesh.castShadow = true;
            scene.add(blockMesh);
            
            // Wireframe
            const wireframe = new THREE.LineSegments(
                new THREE.EdgesGeometry(blockMesh.geometry),
                new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            blockMesh.add(wireframe);
            
            blocks.push({
                mesh: blockMesh,
                points: points
            });
        }
        
        function createLevel(level) {
            // Clear existing blocks
            blocks.forEach(block => {
                if (block.mesh) scene.remove(block.mesh);
            });
            blocks.length = 0;
            
            const cols = 8;
            const rows = 6;
            const blockWidth = 1;
            const blockDepth = 0.4;
            const spacing = 0.1;
            
            const startZ = -areaDepth/2 + 2;
            
            // Different patterns for each level
            switch(level) {
                case 1: // Pyramid
                    for (let row = 0; row < 5; row++) {
                        const colsInRow = 8 - row;
                        for (let col = 0; col < colsInRow; col++) {
                            const x = (col - colsInRow/2 + 0.5) * (blockWidth + spacing);
                            const z = startZ + row * (blockDepth + spacing);
                            createBlock(x, z, row, (5 - row) * 10);
                        }
                    }
                    break;
                    
                case 2: // Checkerboard
                    for (let row = 0; row < 6; row++) {
                        for (let col = 0; col < cols; col++) {
                            if ((row + col) % 2 === 0) {
                                const x = (col - cols/2 + 0.5) * (blockWidth + spacing);
                                const z = startZ + row * (blockDepth + spacing);
                                createBlock(x, z, row, (6 - row) * 10);
                            }
                        }
                    }
                    break;
                    
                case 3: // Diamond
                    const centerRow = 3;
                    for (let row = 0; row < 7; row++) {
                        const distance = Math.abs(row - centerRow);
                        const colsInRow = 7 - distance * 2;
                        for (let col = 0; col < colsInRow; col++) {
                            const x = (col - colsInRow/2 + 0.5) * (blockWidth + spacing);
                            const z = startZ + row * (blockDepth + spacing);
                            createBlock(x, z, distance, (4 - distance) * 10);
                        }
                    }
                    break;
                    
                case 4: // Zigzag
                    for (let row = 0; row < 8; row++) {
                        const offset = Math.floor(row / 2) % 2 === 0 ? 0 : 4;
                        for (let col = 0; col < 4; col++) {
                            const x = (col + offset - cols/2 + 0.5) * (blockWidth + spacing);
                            const z = startZ + row * (blockDepth + spacing);
                            createBlock(x, z, row % 5, (8 - row) * 10);
                        }
                    }
                    break;
                    
                case 5: // Full wall
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < cols; col++) {
                            const x = (col - cols/2 + 0.5) * (blockWidth + spacing);
                            const z = startZ + row * (blockDepth + spacing);
                            createBlock(x, z, row, (8 - row) * 10);
                        }
                    }
                    break;
            }
        }
        
        // Particles
        const particles = [];
        
        function createParticles(x, y, z, color, count = 20) {
            for (let i = 0; i < count; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 4, 4),
                    new THREE.MeshBasicMaterial({ color })
                );
                particle.position.set(x, y, z);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.15,
                    (Math.random() - 0.5) * 0.2
                );
                particle.life = 1;
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        // Game state
        let score = 0;
        let lives = 3;
        let level = 1;
        let ballVelocity = new THREE.Vector3(0, 0, 0);
        let ballLaunched = false;
        let gameRunning = true;
        
        // Input
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const crosshair = document.getElementById('crosshair');
        
        // Create invisible plane for raycasting
        const paddlePlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();
        
        window.addEventListener('mousemove', (e) => {
            // Update crosshair position
            crosshair.style.left = e.clientX + 'px';
            crosshair.style.top = e.clientY + 'px';
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            // Raycast from camera to paddle plane
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(paddlePlane, intersectPoint);
            
            // Move paddle to intersection point
            if (intersectPoint) {
                paddle.position.x = THREE.MathUtils.clamp(
                    intersectPoint.x,
                    -areaWidth/2 + 1,
                    areaWidth/2 - 1
                );
                
                if (!ballLaunched) {
                    ball.position.x = paddle.position.x;
                }
            }
        });
        
        window.addEventListener('click', (e) => {
            if (!ballLaunched && gameRunning) {
                ballLaunched = true;
                ballVelocity.set(
                    (Math.random() - 0.5) * 0.05,
                    0,
                    -0.15
                );
            }
        });
        
        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = score;
        }
        
        function loseLife() {
            lives--;
            document.getElementById('lives').textContent = lives;
            
            if (lives <= 0) {
                gameOver(false);
            } else {
                resetBall();
            }
        }
        
        function resetBall() {
            ballLaunched = false;
            ball.position.set(paddle.position.x, 0.5, 4);
            ballVelocity.set(0, 0, 0);
        }
        
        function nextLevel() {
            level++;
            document.getElementById('level').textContent = level;
            createLevel(level);
            resetBall();
        }
        
        function gameOver(won) {
            gameRunning = false;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over-title').textContent = won ? 'YOU WIN!' : 'GAME OVER';
            const gameOverEl = document.getElementById('game-over');
            gameOverEl.className = 'game-over' + (won ? ' win' : '');
            gameOverEl.style.display = 'block';
        }
        
        function restartGame() {
            score = 0;
            lives = 3;
            level = 1;
            gameRunning = true;
            document.getElementById('score').textContent = '0';
            document.getElementById('lives').textContent = '3';
            document.getElementById('level').textContent = '1';
            document.getElementById('game-over').style.display = 'none';
            createLevel(1);
            resetBall();
        }
        
        // Game loop
        let time = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            
            if (!gameRunning) {
                renderer.render(scene, camera);
                return;
            }
            
            // Ball physics
            if (ballLaunched) {
                ball.position.add(ballVelocity);
                
                // Trail effect
                if (Math.random() > 0.7) {
                    const trail = new THREE.Mesh(trailGeometry, trailMaterial.clone());
                    trail.position.copy(ball.position);
                    trail.life = 0.5;
                    scene.add(trail);
                    trails.push(trail);
                }
                
                // Wall collisions
                if (ball.position.x <= -areaWidth/2 + 0.3 || ball.position.x >= areaWidth/2 - 0.3) {
                    ballVelocity.x *= -1;
                    ball.position.x = THREE.MathUtils.clamp(ball.position.x, -areaWidth/2 + 0.3, areaWidth/2 - 0.3);
                }
                
                if (ball.position.z <= -areaDepth/2 + 0.3) {
                    ballVelocity.z *= -1;
                    ball.position.z = -areaDepth/2 + 0.3;
                }
                
                // Paddle collision
                if (ball.position.z >= paddle.position.z - 0.6 &&
                    ball.position.z <= paddle.position.z + 0.2 &&
                    Math.abs(ball.position.x - paddle.position.x) < 1.3) {
                    
                    ballVelocity.z = -Math.abs(ballVelocity.z);
                    // Add spin based on hit position
                    const hitOffset = (ball.position.x - paddle.position.x) / 1.3;
                    ballVelocity.x = hitOffset * 0.1;
                    ball.position.z = paddle.position.z - 0.6;
                }
                
                // Block collisions
                for (let i = blocks.length - 1; i >= 0; i--) {
                    const block = blocks[i];
                    const blockBox = new THREE.Box3().setFromObject(block.mesh);
                    const ballBox = new THREE.Box3().setFromObject(ball);
                    
                    if (blockBox.intersectsBox(ballBox)) {
                        // Remove block
                        scene.remove(block.mesh);
                        blocks.splice(i, 1);
                        
                        // Particles
                        createParticles(
                            block.mesh.position.x,
                            block.mesh.position.y,
                            block.mesh.position.z,
                            block.mesh.material.color,
                            15
                        );
                        
                        // Bounce
                        ballVelocity.z *= -1;
                        
                        // Score
                        updateScore(block.points);
                        
                        // Check level complete
                        if (blocks.length === 0) {
                            if (level >= 5) {
                                gameOver(true);
                            } else {
                                nextLevel();
                            }
                        }
                        
                        break;
                    }
                }
                
                // Ball out of bounds
                if (ball.position.z > 6) {
                    loseLife();
                }
                
                // Speed up slightly over time
                const speed = Math.sqrt(ballVelocity.x ** 2 + ballVelocity.z ** 2);
                if (speed < 0.25) {
                    ballVelocity.multiplyScalar(1.001);
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.velocity);
                p.velocity.y -= 0.005;
                p.life -= 0.02;
                p.material.opacity = p.life;
                
                if (p.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
            
            // Update trails
            for (let i = trails.length - 1; i >= 0; i--) {
                const t = trails[i];
                t.life -= 0.03;
                t.material.opacity = t.life;
                
                if (t.life <= 0) {
                    scene.remove(t);
                    trails.splice(i, 1);
                }
            }
            
            // Ball rotation
            ball.rotation.x += 0.1;
            ball.rotation.y += 0.05;
            
            // Light follows ball
            glowLight.position.copy(ball.position);
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        createLevel(1);
        animate();
    </script>
</body>
</html>

