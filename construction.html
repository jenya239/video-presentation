<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construction Process Animation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
        }
        
        #canvas {
            display: block;
        }
        
        .info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        .info-panel h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #4fc3f7;
        }
        
        .stage-info {
            margin: 10px 0;
            padding: 10px;
            background: rgba(79, 195, 247, 0.2);
            border-radius: 5px;
        }
        
        .material-info {
            margin: 5px 0;
            font-size: 12px;
            color: #aaa;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #29b6f6);
            width: 0%;
            transition: width 0.3s;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
        }
        
        .controls button {
            background: #4fc3f7;
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .controls button:hover {
            background: #29b6f6;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="info-panel">
        <h2>Construction Process</h2>
        <div class="stage-info">
            <div id="stage-name">Stage: Foundation</div>
            <div id="materials-used">Materials: 0</div>
            <div class="material-info" id="material-details">
                Concrete blocks: 250x250x500mm
            </div>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
    </div>
    
    <div class="controls">
        <button onclick="changeSpeed(-1)">◄ Slower</button>
        <button onclick="togglePause()">⏸ Pause</button>
        <button onclick="changeSpeed(1)">Faster ►</button>
        <button onclick="resetConstruction()">↻ Reset</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue
        scene.fog = new THREE.Fog(0x87ceeb, 50, 200);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        camera.position.set(15, 12, 15);
        camera.lookAt(0, 3, 0);
        
        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(30, 50, 20);
        sunLight.castShadow = true;
        sunLight.shadow.camera.left = -20;
        sunLight.shadow.camera.right = 20;
        sunLight.shadow.camera.top = 20;
        sunLight.shadow.camera.bottom = -20;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b7355,
            roughness: 0.9
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Materials library (real dimensions in meters)
        const materials = {
            // Concrete foundation blocks: 250x250x500mm
            foundationBlock: { w: 0.5, h: 0.25, d: 0.25, color: 0x808080 },
            // Brick: 250x120x65mm
            brick: { w: 0.25, h: 0.065, d: 0.12, color: 0xb22222 },
            // Concrete block: 400x200x200mm
            concreteBlock: { w: 0.4, h: 0.2, d: 0.2, color: 0xa9a9a9 },
            // Timber beam: 50x150mm, length varies
            beam: { w: 0.05, h: 0.15, d: 1.0, color: 0x8b4513 },
            // Plywood sheet: 1220x2440x15mm
            plywood: { w: 1.22, h: 0.015, d: 2.44, color: 0xdeb887 },
            // Concrete slab: varies
            slab: { w: 1.0, h: 0.15, d: 1.0, color: 0x696969 },
            // Roof tile: 300x400mm
            roofTile: { w: 0.3, h: 0.02, d: 0.4, color: 0x8b0000 }
        };
        
        // Construction elements
        const constructionElements = [];
        let buildingProgress = 0;
        let currentStage = 0;
        let paused = false;
        let speed = 1;
        
        // Building dimensions (small house: 6x8 meters)
        const buildingWidth = 6;
        const buildingDepth = 8;
        const wallHeight = 3;
        
        // Construction stages
        const stages = [
            {
                name: 'Foundation',
                duration: 100,
                material: 'foundationBlock',
                build: () => buildFoundation()
            },
            {
                name: 'Floor Slab',
                duration: 50,
                material: 'slab',
                build: () => buildFloorSlab()
            },
            {
                name: 'Walls - Layer 1',
                duration: 120,
                material: 'brick',
                build: () => buildWallLayer(0)
            },
            {
                name: 'Walls - Layer 2',
                duration: 120,
                material: 'brick',
                build: () => buildWallLayer(1)
            },
            {
                name: 'Walls - Layer 3',
                duration: 120,
                material: 'brick',
                build: () => buildWallLayer(2)
            },
            {
                name: 'Window/Door Frames',
                duration: 60,
                material: 'beam',
                build: () => buildFrames()
            },
            {
                name: 'Roof Structure',
                duration: 80,
                material: 'beam',
                build: () => buildRoofStructure()
            },
            {
                name: 'Roof Covering',
                duration: 100,
                material: 'roofTile',
                build: () => buildRoofCovering()
            }
        ];
        
        function createBlock(material, x, y, z, rotateY = 0) {
            const mat = materials[material];
            const geometry = new THREE.BoxGeometry(mat.w, mat.h, mat.d);
            const meshMaterial = new THREE.MeshStandardMaterial({ 
                color: mat.color,
                roughness: 0.8,
                metalness: 0.1
            });
            const mesh = new THREE.Mesh(geometry, meshMaterial);
            mesh.position.set(x, y, z);
            mesh.rotation.y = rotateY;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Animation: appear from below
            mesh.userData.targetY = y;
            mesh.position.y = -2;
            
            scene.add(mesh);
            constructionElements.push(mesh);
            return mesh;
        }
        
        function buildFoundation() {
            const mat = materials.foundationBlock;
            const spacing = mat.w;
            
            // Front and back walls
            for (let x = -buildingWidth/2; x < buildingWidth/2; x += spacing) {
                createBlock('foundationBlock', x, mat.h/2, -buildingDepth/2);
                createBlock('foundationBlock', x, mat.h/2, buildingDepth/2);
            }
            
            // Side walls
            for (let z = -buildingDepth/2 + spacing; z < buildingDepth/2; z += spacing) {
                createBlock('foundationBlock', -buildingWidth/2, mat.h/2, z);
                createBlock('foundationBlock', buildingWidth/2, mat.h/2, z);
            }
        }
        
        function buildFloorSlab() {
            const mat = materials.slab;
            for (let x = -buildingWidth/2; x < buildingWidth/2; x += mat.w) {
                for (let z = -buildingDepth/2; z < buildingDepth/2; z += mat.d) {
                    createBlock('slab', x + mat.w/2, materials.foundationBlock.h + mat.h/2, z + mat.d/2);
                }
            }
        }
        
        function buildWallLayer(layer) {
            const floorHeight = materials.foundationBlock.h + materials.slab.h;
            const mat = materials.brick;
            const y = floorHeight + mat.h/2 + layer * mat.h * 3;
            const spacing = mat.w;
            
            // Number of rows per layer
            for (let row = 0; row < 3; row++) {
                const currentY = y + row * mat.h;
                const offset = (row % 2) * (mat.w / 2); // Brick pattern offset
                
                // Front wall (with door opening)
                for (let x = -buildingWidth/2; x < buildingWidth/2; x += spacing) {
                    if (layer === 0 && row < 2 && Math.abs(x) < 0.5) continue; // Door opening
                    createBlock('brick', x + offset, currentY, -buildingDepth/2 + mat.d/2);
                }
                
                // Back wall
                for (let x = -buildingWidth/2; x < buildingWidth/2; x += spacing) {
                    createBlock('brick', x + offset, currentY, buildingDepth/2 - mat.d/2);
                }
                
                // Left wall (with window opening)
                for (let z = -buildingDepth/2 + spacing; z < buildingDepth/2; z += spacing) {
                    if (layer === 1 && row === 1 && Math.abs(z) < 1) continue; // Window opening
                    createBlock('brick', -buildingWidth/2 + mat.d/2, currentY, z + offset);
                }
                
                // Right wall (with window opening)
                for (let z = -buildingDepth/2 + spacing; z < buildingDepth/2; z += spacing) {
                    if (layer === 1 && row === 1 && Math.abs(z) < 1) continue; // Window opening
                    createBlock('brick', buildingWidth/2 - mat.d/2, currentY, z + offset);
                }
            }
        }
        
        function buildFrames() {
            const wallTop = materials.foundationBlock.h + materials.slab.h + materials.brick.h * 9;
            const mat = materials.beam;
            
            // Door frame
            createBlock('beam', -0.5, wallTop/2, -buildingDepth/2, 0);
            createBlock('beam', 0.5, wallTop/2, -buildingDepth/2, 0);
            createBlock('beam', 0, wallTop - mat.h/2, -buildingDepth/2, 0);
            
            // Window frames (simplified)
            // Left wall window
            createBlock('beam', -buildingWidth/2, wallTop * 0.6, 0, Math.PI/2);
            // Right wall window
            createBlock('beam', buildingWidth/2, wallTop * 0.6, 0, Math.PI/2);
        }
        
        function buildRoofStructure() {
            const wallTop = materials.foundationBlock.h + materials.slab.h + materials.brick.h * 9;
            const mat = materials.beam;
            const roofHeight = 2;
            
            // Ridge beam
            for (let z = -buildingDepth/2; z < buildingDepth/2; z += 1) {
                createBlock('beam', 0, wallTop + roofHeight, z, 0);
            }
            
            // Rafters
            const rafterCount = 8;
            for (let i = 0; i <= rafterCount; i++) {
                const z = -buildingDepth/2 + (buildingDepth / rafterCount) * i;
                
                // Left rafter
                const leftBeam = createBlock('beam', -buildingWidth/4, wallTop + roofHeight/2, z, 0);
                leftBeam.rotation.z = Math.PI / 6;
                
                // Right rafter
                const rightBeam = createBlock('beam', buildingWidth/4, wallTop + roofHeight/2, z, 0);
                rightBeam.rotation.z = -Math.PI / 6;
            }
        }
        
        function buildRoofCovering() {
            const wallTop = materials.foundationBlock.h + materials.slab.h + materials.brick.h * 9;
            const mat = materials.roofTile;
            const roofHeight = 2;
            const roofPitch = Math.PI / 6;
            
            // Left side
            for (let x = -buildingWidth/2; x < 0; x += mat.w) {
                for (let z = -buildingDepth/2; z < buildingDepth/2; z += mat.d) {
                    const distFromCenter = Math.abs(x);
                    const y = wallTop + roofHeight - distFromCenter * Math.tan(roofPitch);
                    const tile = createBlock('roofTile', x, y, z, 0);
                    tile.rotation.x = -roofPitch;
                }
            }
            
            // Right side
            for (let x = 0; x < buildingWidth/2; x += mat.w) {
                for (let z = -buildingDepth/2; z < buildingDepth/2; z += mat.d) {
                    const distFromCenter = Math.abs(x);
                    const y = wallTop + roofHeight - distFromCenter * Math.tan(roofPitch);
                    const tile = createBlock('roofTile', x, y, z, 0);
                    tile.rotation.x = roofPitch;
                }
            }
        }
        
        // Animation
        let time = 0;
        let stageProgress = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (!paused) {
                time += 0.016 * speed;
                
                // Update current stage
                if (currentStage < stages.length) {
                    stageProgress += speed;
                    
                    if (stageProgress >= stages[currentStage].duration) {
                        currentStage++;
                        stageProgress = 0;
                        
                        if (currentStage < stages.length) {
                            stages[currentStage].build();
                        }
                    }
                    
                    // Update UI
                    if (currentStage < stages.length) {
                        document.getElementById('stage-name').textContent = `Stage: ${stages[currentStage].name}`;
                        const mat = materials[stages[currentStage].material];
                        document.getElementById('material-details').textContent = 
                            `${stages[currentStage].material}: ${Math.round(mat.w*1000)}x${Math.round(mat.h*1000)}x${Math.round(mat.d*1000)}mm`;
                        
                        const totalProgress = (currentStage * 100 + (stageProgress / stages[currentStage].duration) * 100) / stages.length;
                        document.getElementById('progress').style.width = totalProgress + '%';
                    }
                    
                    document.getElementById('materials-used').textContent = `Materials: ${constructionElements.length}`;
                }
                
                // Animate blocks rising
                constructionElements.forEach((element, i) => {
                    if (element.position.y < element.userData.targetY) {
                        element.position.y += 0.05 * speed;
                    }
                });
                
                // Rotate camera slowly
                camera.position.x = Math.cos(time * 0.1) * 20;
                camera.position.z = Math.sin(time * 0.1) * 20;
                camera.lookAt(0, 3, 0);
            }
            
            renderer.render(scene, camera);
        }
        
        function togglePause() {
            paused = !paused;
            document.querySelector('.controls button:nth-child(2)').textContent = paused ? '▶ Play' : '⏸ Pause';
        }
        
        function changeSpeed(delta) {
            speed = Math.max(0.5, Math.min(5, speed + delta * 0.5));
        }
        
        function resetConstruction() {
            constructionElements.forEach(el => scene.remove(el));
            constructionElements.length = 0;
            currentStage = 0;
            stageProgress = 0;
            time = 0;
            stages[0].build();
        }
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start construction
        stages[0].build();
        animate();
    </script>
</body>
</html>

