<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nord Projects Ecosystem</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: 'Courier New', monospace;
            color: #00ff88;
        }
        #canvas { display: block; }
        .legend {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 15, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            font-size: 14px;
            max-width: 300px;
        }
        .legend h2 {
            margin: 0 0 15px 0;
            font-size: 20px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
        }
        .stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 15, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            font-size: 18px;
        }
        .title {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 15, 0.9);
            padding: 20px 30px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            text-align: right;
        }
        .title h1 {
            margin: 0;
            font-size: 32px;
            color: #00ff88;
            text-shadow: 0 0 20px #00ff88;
        }
        .title .subtitle {
            margin-top: 10px;
            font-size: 16px;
            color: #00ffff;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="title">
        <h1>NORD PROJECTS</h1>
        <div class="subtitle">Microservices Ecosystem</div>
    </div>
    
    <div class="legend">
        <h2>COMPONENTS</h2>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff3366;"></div>
            <span>Backend Services</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff88;"></div>
            <span>Frontend Apps</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffaa00;"></div>
            <span>Admin Panels</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ffff;"></div>
            <span>Core Libraries</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff00ff;"></div>
            <span>Infrastructure</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #6666ff;"></div>
            <span>External Services</span>
        </div>
    </div>
    
    <div class="stats">
        <div id="active-services">Active: 0</div>
        <div id="connections">Connections: 0</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0f);
        scene.fog = new THREE.Fog(0x0a0a0f, 30, 80);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        camera.position.set(25, 15, 25);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.PointLight(0x00ff88, 1, 100);
        mainLight.position.set(0, 20, 0);
        scene.add(mainLight);
        
        const accentLight = new THREE.PointLight(0xff3366, 0.8, 80);
        accentLight.position.set(20, 10, 20);
        scene.add(accentLight);
        
        // Grid
        const gridHelper = new THREE.GridHelper(60, 30, 0x00ff88, 0x003322);
        gridHelper.position.y = -5;
        scene.add(gridHelper);
        
        // Project nodes data
        const projects = [
            // Core backend services
            { name: 'casino-sg\nbackend', type: 'backend', color: 0xff3366, pos: [0, 0, 0], size: 1.5 },
            { name: 'bp-service', type: 'backend', color: 0xff3366, pos: [-6, 0, -3], size: 1.0 },
            { name: 'bp-service2', type: 'backend', color: 0xff3366, pos: [-6, 0, 3], size: 1.0 },
            { name: 'loyalty\nservice', type: 'backend', color: 0xff3366, pos: [-3, 0, -6], size: 1.0 },
            { name: 'notify\nservice', type: 'backend', color: 0xff3366, pos: [3, 0, -6], size: 1.0 },
            { name: 'tg-service', type: 'backend', color: 0xff3366, pos: [6, 0, -3], size: 1.0 },
            
            // Frontend clients
            { name: 'casino-sg\nclient', type: 'frontend', color: 0x00ff88, pos: [-8, 0, 8], size: 1.2 },
            { name: 'client2', type: 'frontend', color: 0x00ff88, pos: [-4, 0, 8], size: 1.0 },
            { name: 'client-core', type: 'frontend', color: 0x00ff88, pos: [0, 0, 8], size: 1.0 },
            
            // Admin panels
            { name: 'casino-sg\nadmin', type: 'admin', color: 0xffaa00, pos: [8, 0, 4], size: 1.2 },
            { name: 'buffalopay\nadmin', type: 'admin', color: 0xffaa00, pos: [8, 0, 0], size: 1.0 },
            { name: 'casino-admin', type: 'admin', color: 0xffaa00, pos: [8, 0, -4], size: 1.0 },
            
            // Core libraries
            { name: 'nest-core', type: 'core', color: 0x00ffff, pos: [0, 3, 0], size: 0.8 },
            { name: 'api-tools', type: 'core', color: 0x00ffff, pos: [3, 3, 0], size: 0.6 },
            
            // Infrastructure
            { name: 'sonarqube', type: 'infra', color: 0xff00ff, pos: [0, -3, -8], size: 0.8 },
            { name: 'VPN\nServers', type: 'infra', color: 0xff00ff, pos: [-8, -3, 0], size: 0.8 },
            
            // Other projects
            { name: 'casino-cms', type: 'backend', color: 0xff3366, pos: [6, 0, 6], size: 1.0 },
            { name: 'casino-2wp', type: 'backend', color: 0xff3366, pos: [-8, 0, -8], size: 1.0 },
            
            // External
            { name: 'Jira', type: 'external', color: 0x6666ff, pos: [12, 2, 0], size: 0.6 },
            { name: 'Git Repos', type: 'external', color: 0x6666ff, pos: [0, 5, 0], size: 0.6 }
        ];
        
        // Connections (service dependencies)
        const connections = [
            // Backend to core
            [0, 12], [1, 12], [2, 12], [3, 12], [4, 12], [5, 12],
            // Backend to api-tools
            [0, 13], [1, 13],
            // Clients to backend
            [6, 0], [7, 0], [8, 0],
            // Admins to backend
            [9, 0], [10, 1], [11, 0],
            // CMS
            [16, 0],
            // SonarQube to all backend
            [14, 0], [14, 1], [14, 3], [14, 4], [14, 5],
            // Jira to admins
            [18, 9], [18, 10], [18, 11],
            // Git to everything
            [19, 0], [19, 6], [19, 9], [19, 12]
        ];
        
        const nodes = [];
        const lines = [];
        
        // Create project nodes
        projects.forEach((proj, i) => {
            const geometry = new THREE.BoxGeometry(proj.size, proj.size, proj.size);
            const material = new THREE.MeshStandardMaterial({
                color: proj.color,
                emissive: proj.color,
                emissiveIntensity: 0.3,
                roughness: 0.3,
                metalness: 0.7
            });
            
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(...proj.pos);
            cube.userData = proj;
            scene.add(cube);
            nodes.push(cube);
            
            // Add wireframe
            const wireframeGeo = new THREE.EdgesGeometry(geometry);
            const wireframeMat = new THREE.LineBasicMaterial({ 
                color: proj.color, 
                linewidth: 2 
            });
            const wireframe = new THREE.LineSegments(wireframeGeo, wireframeMat);
            cube.add(wireframe);
            
            // Add glow sphere
            const glowGeo = new THREE.SphereGeometry(proj.size * 0.8, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({
                color: proj.color,
                transparent: true,
                opacity: 0.2
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            cube.add(glow);
            
            // Add text label using canvas texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 512, 256);
            ctx.fillStyle = '#' + proj.color.toString(16).padStart(6, '0');
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const lines = proj.name.split('\n');
            lines.forEach((line, idx) => {
                ctx.fillText(line, 256, 128 + (idx - lines.length/2 + 0.5) * 50);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(proj.size * 3, proj.size * 1.5, 1);
            sprite.position.y = proj.size * 1.2;
            cube.add(sprite);
        });
        
        // Create connection lines
        connections.forEach(([from, to]) => {
            const fromPos = nodes[from].position;
            const toPos = nodes[to].position;
            
            const points = [
                new THREE.Vector3(fromPos.x, fromPos.y, fromPos.z),
                new THREE.Vector3(toPos.x, toPos.y, toPos.z)
            ];
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ff88,
                opacity: 0.3,
                transparent: true
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            lines.push({ line, from, to, phase: Math.random() * Math.PI * 2 });
        });
        
        // Particles for data flow
        const particleCount = 200;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleColors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            particlePositions[i * 3] = (Math.random() - 0.5) * 40;
            particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 20;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 40;
            
            const color = new THREE.Color();
            color.setHSL(Math.random() * 0.3 + 0.4, 1, 0.5);
            particleColors[i * 3] = color.r;
            particleColors[i * 3 + 1] = color.g;
            particleColors[i * 3 + 2] = color.b;
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.2,
            vertexColors: true,
            transparent: true,
            opacity: 0.6
        });
        
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);
        
        // Animation
        let time = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Rotate nodes
            nodes.forEach((node, i) => {
                node.rotation.y += 0.005;
                node.rotation.x += 0.002;
                
                // Pulse effect
                const scale = 1 + Math.sin(time * 2 + i * 0.5) * 0.05;
                node.scale.set(scale, scale, scale);
            });
            
            // Animate connection lines
            lines.forEach(line => {
                line.phase += 0.03;
                line.line.material.opacity = 0.2 + Math.sin(line.phase) * 0.15;
            });
            
            // Move particles
            const positions = particleGeometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3 + 1] += Math.sin(time + i) * 0.02;
                
                // Wrap around
                if (positions[i * 3 + 1] > 10) positions[i * 3 + 1] = -10;
                if (positions[i * 3 + 1] < -10) positions[i * 3 + 1] = 10;
            }
            particleGeometry.attributes.position.needsUpdate = true;
            
            // Update stats
            document.getElementById('active-services').textContent = `Active: ${nodes.length}`;
            document.getElementById('connections').textContent = `Connections: ${connections.length}`;
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>

